최적화와 메모이제이션
최적화: 웹 서비스의 성능을 개선하는 기술 / 프로그래밍에서 불필요하게 낭비되는 연산을 줄여 렌더링의 성능을 높이는 방법

메모이제이션
- 특정 입력에 대한 결과를 계산해 메모리 어딘가에 저장했다가, 동일한 요청이 들어오면 저장한 결괏값을 제공해 빠르게 응답하는 기술
- 메모하는 방법 이라는 뜻
- 리액트 앱에서 연산 최적화는 대부분 '메모이제이션' 기법을 이용

useMemo
: 특정 함수를 호출 했을 때 그 함수의 반환값을 기억. 그리고 같은 함수를 다시 호출하면 기억해 두었던 값을 반환
const value = useMemo(callback, deps);
deps: 의존성 배열

const vlaue = useMemo(() => {
    return count * count;
}, [count])


고차 컴포넌트
: 컴포넌트의 기능을 다시 사용허기 위한 리액트의 고급 기술
- 인수로 전달된 텀포넌트를 어떤 기능을 추가해 새로운 컴포넌트로 반환하는 함수

횡단 관심사(Cross-Cutting Concerns)
: 비즈니스 로직과 구분되는 공통 기능을 지칭할 때 사용하는 용어

const CompA = () => {
    console.log("컴포넌트가 호출되었습니다.");  // 횡단 관심사
    return <div>CompA</div>;
}
const CompB = () => {
    console.log("컴포넌트가 호출되었습니다.");  // 횡단 관심사
    return <div>CompB</div>;
}

React.memo
- 컴포넌트가 모든 상황에서 리렌더되지 않도록 강화함으로써 서비스를 최적화하는 도구

기본사용법
- 인수로 전달한 컴포넌트를 메오이제이션된 컴포넌트로 만들어 반환
- 강화하고 싶은 컴포넌트를 React.memo로 감싸면 된다.

const memoizedComp = React.memo(Comp);
(Comp: 메모이제이션하려는 컴포넌트)

선언과 동시에 메모이제이션 가능
const CompA = React.memo(() => {
    console.log("컴포넌트가 호출되었습니다.");
    return <div>CompA</div>;
});

useCallback
: 컴포넌트가 리렌더 될 때 내부에 작성된 함수를 다시 생성하지 않도록 메모이제이션하는 리액트 훅

기본 사용법)
const memoizedFunc = useCallback(func,deps)
deps(의존성 배열)에 담긴 값이 바뀌면 첫 번째 인수로 전달한 콜백 함수를 다시 만들어 반환
첫 번째 인수로 전달한 콜백 함수를 어떤 경우에도 다시 생성되지 않게 하려면 의존성 배열을 빈 배열로 전달

유의사항)
const onCreate = useCallback(() => {
    setState([newItem, ...state]);
},[])

1. useCallback의 첫 번째 인수로 전달한 콜백 함수에서 State 변수에 접근하는 경우 문제가 발생할 수 있다.
2. useCallback으로 전달한 의존성 배열이 빈 배열이므로, 함수 onCreate는 처음 생성된 후에는 컴포넌트가 리렌더 되어도 다시 생성되지 않는다.
3. 이 경우 useCallback에서 전달한 콜백 함수에서 State 변수에 접근하면 컴포넌트를 마운트할 때의 값(State의 초깃값)이 반한됨.
4. 이유는 콜백 함수가 컴포넌트의 마운트 시점 이후에는 다시 생성되지 않기 때문

이 때는 setState의 인수로 콜백 함수를 전달하는 리액트의 '함수형 업데이트' 기능을 이용
const onCreate = useCallback(() => {
    setState((state) => [newItem, ...state]);
},[])


@@ 최적화할 때 유의할 점 @@
1. 최적화는 항상 마지막에 해라
- 최적화 이후에는 만든 기능을 수정하거나 확장하기 어렵다

2. 모든 것을 최적화 할 필요는 없다
- 최적화는 일반적으로 부하가 많으리라 예상되거나, 복잡하고 비싼 연산을 수행하거나, 리스트처럼 컴포넌트가 반복적으로 나타날 것이 예상되는 지점을 대상으로 진행

3. 컴포넌트 구조를 잘 설계했는지 돌아보라
- 컴포넌트를 기능이나 역할 단위로 잘 분리했는지 먼저 확인한 다음 최적화

4. 최적화는 여기서 끝나지 않는다.
- 할 거 더많으니까 공부해라